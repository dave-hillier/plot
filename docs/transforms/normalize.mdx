import {Dot, Line, Plot, RuleX, RuleY, Text, groupY, normalizeX, normalizeY, selectLast, selectMinX} from "replot/react";
import * as d3 from "d3";
import {useState} from "react";

export const stateage = [];
export const stocks = [];
export const xy = normalizeX("sum", {z: "state", x: "population", y: "state"});

# Normalize transform

The **normalize transform** is a specialized [map transform](./map.md) that normalizes series values relative to some basis, say to convert absolute values into relative values. For example, here is an index chart — a type of multi-series line chart — showing the return of several stocks relative to their closing price on a particular date.

<Plot y={{
    type: "log",
    grid: true,
    label: "Change in price (%)",
    tickFormat: ((f) => (x) => f((x - 1) * 100))(d3.format("+d"))
  }}>
  <RuleY data={[1]} />
  <Line data={stocks} {...normalizeY({
      x: "Date",
      y: "Close",
      stroke: "Symbol"
    })} />
  <Text data={stocks} {...selectLast(normalizeY({
      x: "Date",
      y: "Close",
      z: "Symbol",
      text: "Symbol",
      textAnchor: "start",
      dx: 3
    }))} />
</Plot>


The [select transform](./select.md) is used to label the endpoints of each line.

This example uses an [immediately-invoked function expression (IIFE)](https://developer.mozilla.org/en-US/docs/Glossary/IIFE) for the **tickFormat** option so that the [d3.format](https://d3js.org/d3-format) only needs to be constructed once.
The normalize transform converts absolute values into relative ones. So, if **y** is [*y₀*, *y₁*, *y₂*, …] and the *first* basis is used with [normalizeY](#normalizeY), the resulting output **y** channel is [*y₀* / *y₀*, *y₁* / *y₀*, *y₂* / *y₀*, …]. But it’s a bit more complicated than this in practice since **y** is first grouped by **z**, **fill**, or **stroke** into separate series.

As another example, the normalize transform can be used to compute proportional demographics from absolute populations. The plot below compares the demographics of U.S. states: color represents age group, **y** represents the state, and **x** represents the proportion of the state’s population in that age group.

<Plot height={660} axis={null} grid x={{
    axis: "top",
    label: "Population (%)",
    percent: true
  }} color={{
    scheme: "spectral",
    domain: stateage.ages, // in age order
    legend: true
  }}>
  <RuleX data={[0]} />
  <RuleY data={stateage} {...groupY({x1: "min", x2: "max"}, {...xy, sort: {y: "x1"}})} />
  <Dot data={stateage} {...xy} fill="age" title="age" />
  <Text data={stateage} {...selectMinX({...xy, textAnchor: "end", dx: -6, text: "state"})} />
</Plot>

```js
xy = Plot.normalizeX("sum", {z: "state", x: "population", y: "state"})
```


To reduce code duplication, pull shared options out into an object (here `xy`) and then merge them into each mark’s options using the spread operator (`...`).
## Normalize options

The **basis** option specifies how to normalize the series values; it is one of:

* *first* - the first value, as in an index chart; the default
* *last* - the last value
* *min* - the minimum value
* *max* - the maximum value
* *mean* - the mean value (average)
* *median* - the median value
* *pXX* - the percentile value, where XX is a number in [00,99]
* *sum* - the sum of values
* *extent* - the minimum is mapped to zero, and the maximum to one
* *deviation* - subtract the mean, then divide by the standard deviation
* a function to be passed an array of values, returning the desired basis
* a function to be passed an index and channel value array, returning the desired basis

## normalize(*basis*) <VersionBadge version="0.2.3" />
```js
Plot.map({y: Plot.normalize("first")}, {x: "Date", y: "Close", stroke: "Symbol"})
```

Returns a normalize map method for the given *basis*, suitable for use with the [map transform](./map.md).

## normalizeX(*basis*, *options*)
```js
Plot.normalizeX("first", {y: "Date", x: "Close", stroke: "Symbol"})
```

Like [mapX](./map.md#mapX), but applies the normalize map method with the given *basis*. The **basis** option can also be mixed into the specified *options* like so:

```js
Plot.normalizeX({basis: "first", y: "Date", x: "Close", stroke: "Symbol"})
```

If not specified, the *basis* defaults to *first*.

## normalizeY(*basis*, *options*)
```js
Plot.normalizeY("first", {x: "Date", y: "Close", stroke: "Symbol"})
```

Like [mapY](./map.md#mapY), but applies the normalize map method with the given *basis*. The **basis** option can also be mixed into the specified *options* like so:

```js
Plot.normalizeY({basis: "first", x: "Date", y: "Close", stroke: "Symbol"})
```

If not specified, the *basis* defaults to *first*.
