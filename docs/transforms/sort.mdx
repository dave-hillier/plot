import {Dot, DotX, Geo, Line, Plot, RuleY, dodgeY, geoCentroid} from "replot/react";
import * as d3 from "d3";
import {useState, useEffect} from "react";
import * as topojson from "topojson-client";
import cars from "../data/cars.ts";
import bls from "../data/bls-industry-unemployment.ts";

export const counties = [];
export const statemesh = [];
export const sorted = true;
export const setSorted = () => {};
export const order = "ascending";
export const setOrder = () => {};

{/*
// TODO: manually convert: Promise.all([
// TODO: manually convert: d3.json("../data/us-counties-10m.json"),
// TODO: manually convert: d3.csv("../data/us-county-population.csv")
// TODO: manually convert: ]).then(([_us, _population]) => {
// TODO: manually convert: const map = new Map(_population.map((d) => [d.state + d.county, +d.population]));
// TODO: manually convert: _us.objects.counties.geometries.forEach((g) => (g.properties.population = map.get(g.id)));
// TODO: manually convert: us.value = _us;
*/}

# Sort transform

The **sort transform** sorts a mark’s index to change the effective order of data. The sort transform affects the order in which a mark’s graphical elements are drawn ([z-order](https://en.wikipedia.org/wiki/Z-order)), which can have a dramatic effect when these elements overlap. For example, see the bubble map of U.S. county population below; when the null sort order is used for input order, many small dots are hidden underneath larger ones.

<p>
  <label className="label-input">
    Sort by descending radius (r):
    <input type="checkbox" checked={sorted} onChange={(e) => setSorted(e.target.checked)} />
  </label>
</p>

<Plot projection="albers-usa">
  <Geo data={statemesh} strokeOpacity={0.4} />
  <Dot data={counties} {...geoCentroid({
      r: (d) => d.properties.population,
      fill: "currentColor",
      stroke: "var(--vp-c-bg)",
      strokeWidth: 1,
      sort: sorted ? {channel: "-r"} : null
    })} />
</Plot>


Dots are sorted by descending **r** by default, so you may not need the **sort** option.
The sort transform can be applied either via the **sort** [mark option](../features/marks.md#mark-options), as above, or as an explicit [sort transform](#sort). The latter is generally only needed when composing multiple transforms, or to disambiguate the sort transform from imputed ordinal scale domains, *i.e.*, [scale sorting](../features/scales.md#sort-mark-option).

As another example, in the line chart of unemployment rates below, lines for metropolitan areas in Michigan (which saw exceptionally high unemployment following the [financial crisis of 2008](https://en.wikipedia.org/wiki/2007–2008_financial_crisis), in part due to the [auto industry collapse](https://en.wikipedia.org/wiki/2008–2010_automotive_industry_crisis)) are highlighted in <span style={{borderBottom: "solid 2px var(--vp-c-red)"}}>red</span>, and the **sort** option is used to draw them on top of other series.

<Plot y={{
    grid: true,
    label: "Unemployment (%)"
  }} color={{
    domain: [false, true],
    range: ["#ccc", "red"]
  }}>
  <RuleY data={[0]} />
  <Line data={bls} x="date" y="unemployment" z="division" sort={(d) => /, MI /.test(d.division)} stroke={(d) => /, MI /.test(d.division)} />
</Plot>


You could say `sort: {channel: "stroke"}` here to avoid repeating the test function.
The index order also affects the behavior of certain transforms such as [stack](./stack.md) and [dodge](./dodge.md).

<p>
  <span className="label-input">
    Sort x order:
    <label style={{marginLeft: "0.5em"}}><input type="radio" name="order" value="ascending" checked={order === "ascending"} onChange={(e) => setOrder(e.target.value)} /> ascending</label>
    <label style={{marginLeft: "0.5em"}}><input type="radio" name="order" value="descending" checked={order === "descending"} onChange={(e) => setOrder(e.target.value)} /> descending</label>
  </span>
</p>

<Plot height={180}>
  <DotX data={cars} {...dodgeY({
      x: "weight (lb)",
      title: "name",
      fill: "currentColor",
      sort: {channel: "x", order}
    })} />
</Plot>

The closely-related [reverse transform](#reverse) likewise reverses the mark index, while the [shuffle transform](#shuffle) for randomizes the mark index’s order.

## sort(*order*, *options*)
```js
Plot.sort("body_mass_g", {x: "culmen_length_mm", y: "culmen_depth_mm"})
```

Sorts the data by the specified *order*, which is one of:

- a comparator function, as with [*array*.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
- an accessor function
- a field name
- a `\{*channel*, *order*\}` object

In the object case, the **channel** option specifies the name of the channel, while the **order** option specifies *ascending* (the default) or *descending* order. You can also use the shorthand <span style={{whiteSpace: "nowrap"}}>*-name* <VersionBadge version="0.6.7" /></span> to sort by descending order of the channel with the given *name*. For example, `sort: {channel: "-r"}` will sort by descending radius (**r**).

In the function case, if the sort function does not take exactly one argument, it is interpreted as a comparator function; otherwise it is interpreted as an accessor function.

## shuffle(*options*)
```js
Plot.shuffle({x: "culmen_length_mm", y: "culmen_depth_mm"})
```

Shuffles the data randomly. If a **seed** option is specified, a [linear congruential generator](https://d3js.org/d3-random#randomLcg) with the given seed is used to generate random numbers; otherwise, Math.random is used.

## reverse(*options*)
```js
Plot.reverse({x: "culmen_length_mm", y: "culmen_depth_mm"})
```

Reverses the order of the data.
