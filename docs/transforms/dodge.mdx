import {Dot, DotX, Plot, RectY, RuleX, RuleY, Text, binX, dodgeX, dodgeY} from "replot/react";
import * as d3 from "d3";
import {useState, useEffect} from "react";
import cars from "../data/cars.ts";
import penguins from "../data/penguins.ts";

export const ipos = [];
export const anchor = "middle";
export const setAnchor = () => {};
export const r = 3;
export const setR = () => {};
export const padding = 1;
export const setPadding = () => {};

# Dodge transform <VersionBadge version="0.5.0" />

Given one position dimension (either **x** or **y**), the **dodge** transform computes the other position dimension such that dots are packed densely without overlapping. The [dodgeX transform](#dodgeX) computes **x** (horizontal position) given **y** (vertical position), while the [dodgeY transform](#dodgeY) computes **y** given **x**.

The dodge transform is commonly used to produce beeswarm üêù plots, a way of showing a one-dimensional distribution that preserves the visual identity of individual data points. For example, the dots below represent the weights of cars; the rough shape of the pile gives a sense of the overall distribution (peaking around 2,100 pounds), and you can hover an individual dot to see which car it represents.

<Plot height={160}>
  <DotX data={cars} {...dodgeY({x: "weight (lb)", title: "name", fill: "currentColor"})} />
</Plot>

Compare this to a conventional histogram using a [rect mark](../marks/rect.md).

<Plot height={180}>
  <RectY data={cars} {...binX({y: "count"}, {x: "weight (lb)"})} />
  <RuleY data={[0]} />
</Plot>

The dodge transform works with Plot‚Äôs [faceting system](../features/facets.md), allowing independent beeswarm plots on discrete partitions of the data. Below, penguins are grouped by species and colored by sex, while vertical‚ÜïÔ∏é position (**y**) encodes body mass.

<Plot y={{grid: true}} color={{legend: true}}>
  <Dot data={penguins} {...dodgeX("middle", {fx: "species", y: "body_mass_g", fill: "sex"})} />
</Plot>

Beeswarm plots avoid the occlusion problem of dense scatterplots and barcode plots.

<Plot>
  <DotX data={cars} x="weight (lb)" />
</Plot>

<Plot>
  <RuleX data={cars} x="weight (lb)" />
</Plot>

The **anchor** option specifies the layout baseline: the optimal output position. For the dodgeX transform, the supported anchors are: _left_ (default), _middle_, _right_. For the dodgeY transform, the supported anchors are: _bottom_ (default), _middle_, _top_. When the _middle_ anchor is used, the dots are placed symmetrically around the baseline.

<p>
  <label className="label-input">
    Anchor:
    <select value={anchor} onChange={(e) => setAnchor(e.target.value)}>
      <option>top</option>
      <option>middle</option>
      <option>bottom</option>
    </select>
  </label>
</p>

<Plot height={180}>
  <Dot data={cars} {...dodgeY(anchor, {x: "weight (lb)", fill: "currentColor"})} />
</Plot>

When using dodgeY, you must typically specify the plot‚Äôs **height** to create suitable space for the layout. The dodge transform is not currently able to set the height automatically. For dodgeX, the default **width** of 640 is often sufficient, though you may need to adjust it as well depending on your data.

The dodge transform differs from the [stack transform](./stack.md) in that the dots do not need the exact same input position to avoid overlap; the dodge transform respects the radius **r** of each dot. Try adjusting the radius below to see the effect.

<p>
  <label className="label-input">
    Radius (r):
    <input type="range" value={r} onChange={(e) => setR(Number(e.target.value))} min="0.5" max="10" step="0.1" />
    <span style={{fontVariantNumeric: "tabular-nums"}}>{r.toLocaleString("en-US", {minimumFractionDigits: 1})}</span>
  </label>
</p>

<Plot height={180}>
  <Dot data={cars} {...dodgeY({x: "weight (lb)", r, fill: "currentColor"})} />
</Plot>

The dodge transform also supports a **padding** option (default 1), which specifies the minimum separating distance between dots. Increase it for more breathing room.

<p>
  <label className="label-input">
    Padding:
    <input type="range" value={padding} onChange={(e) => setPadding(Number(e.target.value))} min="-1" max="5" step="0.1" />
    <span style={{fontVariantNumeric: "tabular-nums"}}>{padding.toLocaleString("en-US", {minimumFractionDigits: 1})}</span>
  </label>
</p>

<Plot height={180}>
  <Dot data={cars} {...dodgeY({x: "weight (lb)", padding, fill: "currentColor"})} />
</Plot>

If **r** is a channel, the dodge transform will position circles of varying radius. The chart below shows twenty years of IPO offerings leading up to Facebook‚Äôs $104B offering in 2012; each circle is sized proportionally to the associated company‚Äôs valuation at IPO. (This data comes from [‚ÄúThe Facebook Offering: How It Compares‚Äù](https://archive.nytimes.com/www.nytimes.com/interactive/2012/05/17/business/dealbook/how-the-facebook-offering-compares.html?hp) by Jeremy Ashkenas, Matthew Bloch, Shan Carter, and Amanda Cox.) Facebook‚Äôs valuation was nearly four times that of Google, the previous record. The 2000 [dot-com bubble](https://en.wikipedia.org/wiki/Dot-com_bubble) is also visible.

<Plot insetRight={10} height={790}>
  <Dot data={ipos} {...dodgeY({
        x: "date",
        r: "rMVOP",
        title: (d) => `${d.NAME}\n${(d.rMVOP / 1e3).toFixed(1)}B`,
        fill: "currentColor"
      })} />
  <Text data={ipos} {...dodgeY({
        filter: (d) => d.rMVOP > 5e3,
        x: "date",
        r: "rMVOP",
        text: (d) => (d.rMVOP / 1e3).toFixed(),
        fill: "var(--vp-c-bg)",
        pointerEvents: "none"
      })} />
</Plot>

The dodge transform can be used with any mark that supports **x** and **y** position. Below, we use the [text mark](../marks/text.md) instead to show company valuations (in billions).

<Plot insetRight={10} height={790}>
  <Text data={ipos} {...dodgeY({
        x: "date",
        r: "rMVOP",
        text: (d) => (d.rMVOP / 1e3).toFixed(1),
        title: "NAME",
        fontSize: (d) => Math.min(22, Math.cbrt(d.rMVOP / 1e3) * 6)
      })} />
</Plot>

The dodge transform places dots sequentially, each time finding the closest position to the baseline that avoids intersection with previously-placed dots. Because this is a [greedy algorithm](https://en.wikipedia.org/wiki/Greedy_algorithm), the resulting layout depends on the input order. When **r** is a channel, dots are sorted by descending radius by default such that the largest dots are placed closest to the baseline. Otherwise, dots are placed in input order by default.

To adjust the dodge layout, use the [sort transform](./sort.md). For example, if the **sort** option uses the same column as **x**, the dots are arranged in piles leaning right.

<Plot height={180}>
  <DotX data={cars} {...dodgeY({x: "weight (lb)", title: "name", fill: "currentColor", sort: "weight (lb)"})} />
</Plot>

Reversing the sort order produces piles leaning left.

<Plot height={180}>
  <DotX data={cars} {...dodgeY({x: "weight (lb)", title: "name", fill: "currentColor", sort: "weight (lb)", reverse: true})} />
</Plot>


To avoid repeating a channel definition, you can also specify the **sort** option as `{channel: "x"}`.

Unlike a [force-directed beeswarm](https://observablehq.com/@harrystevens/force-directed-beeswarm), the dodge transform exactly preserves the input position dimension, resulting in a more accurate visualization. Also, the dodge transform tends to be faster than the iterative constraint relaxation used in the force-directed approach. We use Mikola Lysenko‚Äôs [interval-tree-1d library](https://github.com/mikolalysenko/interval-tree-1d) for fast intersection testing.
## Dodge options

The dodge transforms accept the following options:

* **padding** ‚Äî a number of pixels added to the radius of the mark to estimate its size
* **anchor** - the dodge anchor; defaults to *left* for dodgeX, or *bottom* for dodgeY

The **anchor** option may one of *middle*, *right*, and *left* for dodgeX, and one of *middle*, *top*, and *bottom* for dodgeY. With the *middle* anchor the piles will grow from the center in both directions; with the other anchors, the piles will grow from the specified anchor towards the opposite direction.

## dodgeY(*dodgeOptions*, *options*)
```js
Plot.dodgeY({x: "date"})
```

Given marks arranged along the *x* axis, the dodgeY transform piles them vertically by defining a *y* position channel that avoids overlapping. The *x* position channel is unchanged.

## dodgeX(*dodgeOptions*, *options*)
```js
Plot.dodgeX({y: "value"})
```

Equivalent to Plot.dodgeY, but piling horizontally, creating a new *x* position channel that avoids overlapping. The *y* position channel is unchanged.
