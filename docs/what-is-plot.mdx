import {Density, Plot, Rect, RectY, RuleY, bin, binX} from "replot/react";
import * as d3 from "d3";
import olympians from "./data/olympians.ts";

{/*
// TODO: manually convert: const olympians = shallowRef([

// TODO: manually convert: {weight: 170, height: 2.21, sex: "male"}

// TODO: manually convert: const {site: {value: {themeConfig: {sidebar}}}} = useData();
// TODO: convert computed: const paths = computed(() => {
// TODO: manually convert: const paths = [];
// TODO: manually convert: (function visit(node, path) {
// TODO: manually convert: paths.push({path, link: node.link && `.${node.link}`});
// TODO: manually convert: if (node.items) {
// TODO: manually convert: for (const item of node.items) {
// TODO: manually convert: visit(item, (path === "/" ? path : path + "/") + item.text);

// TODO: manually convert: return paths;
// TODO: manually convert: // https://github.com/observablehq/plot/issues/1703
// TODO: manually convert: function computeTreeWidth(paths) {
// TODO: manually convert: const root = d3.tree().nodeSize([1, 1])(d3.stratify().path((d) => d.path)(paths));
// TODO: manually convert: const [x1, x2] = d3.extent(root, (d) => d.x);
// TODO: manually convert: return x2 - x1;
*/}

# What is Plot?

**Replot** is a free, open-source, JavaScript library for visualizing tabular data, focused on accelerating exploratory data analysis. It has a concise, memorable, yet expressive interface, featuring [scales](./features/scales.md) and [layered marks](./features/marks.md) in the *grammar of graphics* style popularized by [Leland Wilkinson](https://en.wikipedia.org/wiki/Leland_Wilkinson) and [Hadley Wickham](https://en.wikipedia.org/wiki/Hadley_Wickham) and inspired by the earlier ideas of [Jacques Bertin](https://en.wikipedia.org/wiki/Jacques_Bertin). And there are [plenty of examples](https://observablehq.com/@observablehq/plot-gallery) to learn from and copy-paste.

Plot offers two APIs: a concise **imperative API** for vanilla JavaScript environments and a **declarative React component API** for building charts with JSX. Both APIs share the same powerful core — D3 scales, transforms, projections, and mark types — so you get the same expressive visualizations regardless of which API you choose. See the [getting started guide](./getting-started.md) for details on both approaches.

In the spirit of *show don’t tell*, here’s a scatterplot of body measurements of athletes from the [2016 Summer Olympics](https://flother.is/2017/olympic-games-data/).

{/* TODO: manually convert */}
{/* Plot
  .dot(olympians, {x: "weight", y: "height", stroke: "sex"})
  .plot({color: {legend: true}}) */}

A plot specification assigns columns of data (*weight*, *height*, and *sex*) to visual properties of marks (**x**, **y**, and **stroke**). Plot does the rest! You can configure much more, if needed, but Plot’s goal is to help you get a meaningful visualization quickly to accelerate analysis.

This scatterplot suffers from overplotting: many dots are drawn in the same spot, so it’s hard to perceive density. We can fix this by applying a [bin transform](./transforms/bin.md) to group athletes of similar height and weight (and sex), and then use opacity to encode the number of athletes in the bin.

<Plot>
  <Rect data={olympians} {...bin({fillOpacity: "count"}, {x: "weight", y: "height", fill: "sex", inset: 0})} />
</Plot>

Or we could try the [density mark](./marks/density.md).

<Plot>
  <Density data={olympians} x="weight" y="height" stroke="sex" />
</Plot>

A simpler take on this data is to focus on one dimension: weight. We can use the bin transform again to make a histogram with weight on the *x*-axis and frequency on the *y*-axis. This plot uses a [rect mark](./marks/rect.md) and an implicit [stack transform](./transforms/stack.md).

<Plot>
  <RectY data={olympians} {...binX({y: "count"}, {x: "weight", fill: "sex"})} />
</Plot>

Or if we’d prefer to show the two distributions separately as small multiples, we can [facet](./features/facets.md) the data along *y* (keeping the *fill* encoding for consistency, and adding grid lines and a rule at *y* = 0 to improve readability).

<Plot grid>
  <RectY data={olympians} {...binX({y: "count"}, {x: "weight", fill: "sex", fy: "sex"})} />
  <RuleY data={[0]} />
</Plot>

## What can Plot do?

Because marks are composable, and because you can extend Plot with custom marks, you can make almost anything with it — much more than the charts above! The following [tree diagram](./marks/tree.md) of the documentation gives a sense of what’s ”in the box” with Plot. Peruse our [gallery of examples](https://observablehq.com/@observablehq/plot-gallery) for more inspiration.

{/* TODO: PlotRender - manually convert
  axis: null,
  height: computeTreeWidth(paths) * 12,
  marginTop: 4,
  marginRight: 120,
  marginBottom: 4,
  marginLeft: 24,
  marks: [
    Plot.tree(paths, {path: "path", textStroke: "var(--vp-c-bg)", channels: {href: {value: "link", filter: null}}, treeSort: null})
  ]
*/}
