import {Density, Dot, Frame, Geo, Plot} from "replot/react";
import * as d3 from "d3";
import {useState, useEffect} from "react";
import * as topojson from "topojson-client";
import diamonds from "../data/diamonds.ts";
import faithful from "../data/faithful.ts";
import penguins from "../data/penguins.ts";
import walmarts from "../data/walmarts.ts";

export const nation = [];
export const statemesh = [];

export const bandwidth = 20;
export const setBandwidth = () => {};
export const thresholds = 20;
export const setThresholds = () => {};
export const skew = 0;
export const setSkew = () => {};

# Density mark <VersionBadge version="0.5.1" />


For contours of spatially-distributed quantitative values, see the [contour mark](./contour.md).
The **density mark** shows the [estimated density](https://en.wikipedia.org/wiki/Multivariate_kernel_density_estimation) of two-dimensional point clouds. Contours guide the eye towards the local peaks of concentration of the data, much like a topographic map does with elevation. This is especially useful given overplotting in dense datasetS.

<Plot inset={10}>
  <Density data={faithful} x="waiting" y="eruptions" stroke="blue" strokeWidth={0.25} />
  <Density data={faithful} x="waiting" y="eruptions" stroke="blue" thresholds={4} />
  <Dot data={faithful} x="waiting" y="eruptions" fill="currentColor" r={1.5} />
</Plot>

The **bandwidth** option specifies the radius of the [Gaussian kernel](https://en.wikipedia.org/wiki/Gaussian_function) describing the influence of each point as a function of distance; this kernel is summed over a discrete grid covering the plot, and then contours (*isolines*) are derived for values between 0 (exclusive) and the maximum density (exclusive) using the [marching squares algorithm](https://en.wikipedia.org/wiki/Marching_squares).

<p>
  <label className="label-input">
    Bandwidth:
    <input type="range" value={bandwidth} onChange={(e) => setBandwidth(Number(e.target.value))} min="0" max="40" step="0.2" />
    <span style={{fontVariantNumeric: "tabular-nums"}}>{bandwidth.toLocaleString("en-US", {minimumFractionDigits: 1})}</span>
  </label>
</p>

<Plot inset={20}>
  <Density data={faithful} x="waiting" y="eruptions" bandwidth={bandwidth} />
  <Dot data={faithful} x="waiting" y="eruptions" />
</Plot>

The **thresholds** option specifies the number of contour lines (minus one) to be computed, or an explicit array of threshold values. For example, with 4 thresholds and a maximum density of 10, contour lines would be drawn for the values 2.5, 5, and 7.5. The default number of thresholds is 20.

<p>
  <label className="label-input">
    Thresholds:
    <input type="range" value={thresholds} onChange={(e) => setThresholds(Number(e.target.value))} min="1" max="40" step="1" />
    <span style={{fontVariantNumeric: "tabular-nums"}}>{thresholds}</span>
  </label>
</p>

<Plot inset={20}>
  <Density data={faithful} x="waiting" y="eruptions" thresholds={thresholds} />
  <Dot data={faithful} x="waiting" y="eruptions" />
</Plot>

The density mark also works with one-dimensional values:

<Plot height={100} inset={10}>
  <Density data={faithful} x="waiting" stroke="blue" strokeWidth={0.25} bandwidth={10} />
  <Density data={faithful} x="waiting" stroke="blue" thresholds={4} bandwidth={10} />
  <Dot data={faithful} x="waiting" fill="currentColor" r={1.5} />
</Plot>

The density mark supports Plot’s [projection system](../features/projections.md), as in this heatmap showing the density of Walmart stores across the contiguous United States (which is a decent proxy for population density).

<Plot projection="albers" color={{scheme: "turbo"}}>
  <Density data={walmarts} x="longitude" y="latitude" bandwidth={10} fill="density" />
  <Geo data={statemesh} strokeOpacity={0.3} />
  <Geo data={nation} />
  <Dot data={walmarts} x="longitude" y="latitude" r={1} fill="currentColor" />
</Plot>


Use an equal-area projection with the density mark.
By using the _density_ keyword as a **fill** or **stroke** color, you can draw regions with a sequential color encoding.

<Plot inset={10} grid x={{type: "log"}} y={{type: "log"}}>
  <Density data={diamonds} x="carat" y="price" stroke="density" />
</Plot>

To facilitate comparison across facets (**fx** or **fy**) and series (**z**, **stroke**, or **fill**), the thresholds are determined by the series with the highest density. For instance, the chart below shows the highest concentration of penguins, arranged by flipper length and culmen length, on Biscoe island; the contours in the other facets use the same thresholds.

{/* ```js
Plot.plot({
  axis: null,
  marks: [
    Plot.dot(penguins, {x: "flipper_length_mm", y: "culmen_length_mm"}),
    Plot.density(penguins, {x: "flipper_length_mm", y: "culmen_length_mm"})
  ]
})
``` */}

<Plot>
  <Density data={penguins} fx="island" x="flipper_length_mm" y="culmen_length_mm" stroke="density" clip />
  <Frame />
</Plot>

{/* With the default setTings, the density is the local average number of dots on an area of ${tex`100\text{px}^2`} — a square of 10px by 10px. This can be multiplied by the dots’ weights. */}

The **weight** channel specifies the contribution of each data point to the estimated density; it defaults to 1, weighing each point equally. This can be used to give some points more influence than others. Try adjusting the skew slider below to transition between female- and male-weighted density.

<p>
  <label className="label-input">
    Skew (-F/+M):
    <input type="range" value={skew} onChange={(e) => setSkew(Number(e.target.value))} min="-1" max="1" step="0.01" />
    <span style={{fontVariantNumeric: "tabular-nums"}}>{skew.toLocaleString("en-US", {minimumFractionDigits: 2, signDisplay: "always"})}</span>
  </label>
</p>

<Plot inset={10} color={{legend: true}}>
  <Density data={penguins.filter((d) => d.sex)} weight={(d) => d.sex === "FEMALE" ? 1 - skew : 1 + skew} x="flipper_length_mm" y="culmen_length_mm" strokeOpacity={0.5} clip />
  <Dot data={penguins.filter((d) => d.sex)} x="flipper_length_mm" y="culmen_length_mm" stroke="sex" strokeOpacity={(d) => d.sex === "FEMALE" ? 1 - skew : 1 + skew} />
  <Frame />
</Plot>

You can specify a negative weight for points that the density contours should avoid, resulting in regions of influence that do not overlap.

<Plot inset={10} color={{legend: true}}>
  {/* TODO: d3.groups(penguins, (d) => d.species).map(([s]) =>
      Plot.density(penguins, {
        x: "flipper_length_mm",
        y: "culmen_length_mm",
        weight: (d) => d.species === s ? 1 : -1,
        fill: () => s,
        fillOpacity: 0.2,
        thresholds: [0.05]
      })
    ) */}
  <Dot data={penguins} x="flipper_length_mm" y="culmen_length_mm" stroke="species" />
  <Frame />
</Plot>

## Density options

In addition to the [standard mark options](../features/marks.md#mark-options), the following optional channels are supported:

* **x** - the horizontal position; bound to the *x* scale
* **y** - the vertical position; bound to the *y* scale
* **weight** - the contribution to the estimated density

If either of the **x** or **y** channels are not specified, the corresponding position is controlled by the **frameAnchor** option.

The **thresholds** option, which defaults to 20, specifies one more than the number of contours that will be computed at uniformly-spaced intervals between 0 (exclusive) and the maximum density (exclusive). The **thresholds** option may also be specified as an array or iterable of explicit density values. The **bandwidth** option, which defaults to 20, specifies the standard deviation of the Gaussian kernel used for estimation in pixels.

If a **z**, **stroke** or **fill** channel is specified, the input points are grouped by series, and separate setS of contours are generated for each series. If the **stroke** or **fill** is specified as *density*, a color channel is constructed with values representing the density threshold value of each contour.

## density(*data*, *options*)
```js
Plot.density(faithful, {x: "waiting", y: "eruptions"})
```

Returns a new density mark for the given *data* and *options*.
