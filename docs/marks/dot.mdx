import {Dot, DotX, Geo, Plot, RuleX, RuleY, Text, bin, geoCentroid, groupY, identity, normalizeX, selectMinX, stackY2} from "replot/react";
import * as d3 from "d3";
import {useState, useEffect} from "react";
import * as topojson from "topojson-client";
import aapl from "../data/aapl.ts";
import alphabet from "../data/alphabet.ts";
import cars from "../data/cars.ts";
import diamonds from "../data/diamonds.ts";
import gistemp from "../data/gistemp.ts";
import penguins from "../data/penguins.ts";

export const congress = [];
export const counties = [];
export const stateage = [];
export const statemesh = [];
export const sorted = true;
export const setSorted = () => {};

export const xy = normalizeX("sum", {x: "population", y: "state", z: "state"});

{/* Data: counties/statemesh are loaded from us-counties-10m.json with population merged from us-county-population.csv.
   stateage is loaded from us-population-state-age.csv, pivoted to tidy format with {state, age, population} and an .ages property. */}

# Dot mark

The **dot mark** draws circles or other symbols positioned in **x** and **y** as in a scatterplot. For example, the chart below shows the roughly-inverse relationship between car horsepower in *y*‚Üë and fuel efficiency in miles per gallon in *x*‚Üí.

<Plot grid>
  <Dot data={cars} x="economy (mpg)" y="power (hp)" />
</Plot>

Using a function for **x**, we can instead plot the roughly-linear relationship when fuel efficiency is represented as gallons per 100 miles. (For fans of the metric system, 1 gallon per 100 miles is roughly 2.4 liters per 100 km.)

<Plot grid inset={10} x={{label: "Fuel consumption (gallons per 100 miles)"}} y={{label: "Horsepower"}}>
  <Dot data={cars} x={(d) => 100 / d["economy (mpg)"]} y="power (hp)" />
</Plot>

Dots support **stroke** and **fill** channels in addition to position along **x** and **y**. Below, color is used as a redundant encoding to emphasize the rising trend in average global surface temperatures. A *diverging* color scale encodes values below zero blue and above zero red.

<Plot y={{
    grid: true,
    tickFormat: "+f",
    label: "Surface temperature anomaly (¬∞F)"
  }} color={{
    scheme: "BuRd"
  }}>
  <RuleY data={[0]} />
  <Dot data={gistemp} x="Date" y="Anomaly" stroke="Anomaly" />
</Plot>

Dots also support an **r** channel allowing dot size to represent quantitative value. Below, each dot represents a day of trading; the *x*-position represents the day‚Äôs change, while the *y*-position and area (**r**) represent the day‚Äôs trading volume. As you might expect, days with higher volatility have higher trading volume.

<Plot grid x={{
    label: "Daily change (%)",
    tickFormat: "+f",
    percent: true
  }} y={{
    type: "log",
    label: "Daily trading volume"
  }}>
  <RuleX data={[0]} />
  <Dot data={aapl} x={(d) => (d.Close - d.Open) / d.Open} y="Volume" r="Volume" />
</Plot>

With the [bin transform](../transforms/bin.md), sized dots can also be used as an alternative to a [rect-based](./rect.md) heatmap to show a two-dimensional distribution.

<Plot height={640} marginLeft={60} grid x={{label: "Carats"}} y={{label: "Price ($)"}} r={{range: [0, 20]}}>
  <Dot data={diamonds} {...bin({r: "count"}, {x: "carat", y: "price", thresholds: 100})} />
</Plot>


For hexagonal binning, use the [hexbin transform](../transforms/hexbin.md) instead of the bin transform.
While dots are typically positioned in two dimensions (**x** and **y**), one-dimensional dots (only **x** or only **y**) are also supported. Below, dot area is used to represent the frequency of letters in the English language as a compact alternative to a bar chart.

<Plot>
  <Dot data={alphabet} x="letter" r="frequency" />
</Plot>

Dots, together with [rules](./rule.md), can be used as a stylistic alternative to [bars](./bar.md) to produce a lollipop¬†üç≠ chart. (Sadly these lollipops cannot be eaten.)

<Plot x={{label: null, tickPadding: 6, tickSize: 0}} y={{percent: true}}>
  <RuleX data={alphabet} x="letter" y="frequency" strokeWidth={2} />
  <Dot data={alphabet} x="letter" y="frequency" fill="currentColor" r={4} />
</Plot>

A dot may have an ordinal dimension on either **x** and **y**, as in the plot below comparing the demographics of states: color represents age group, **y** represents the state, and **x** represents the proportion of the state‚Äôs population in that age group. The [normalize transform](../transforms/normalize.md) is used to compute the relative proportion of each age group within each state, while the [group transform](../transforms/group.md) is used to pull out the *min* and *max* values for each state for a horizontal [rule](./rule.md).

<Plot height={660} axis={null} grid x={{
    axis: "top",
    label: "Population (%)",
    percent: true
  }} color={{
    scheme: "spectral",
    domain: stateage.ages, // in age order
    legend: true
  }}>
  <RuleX data={[0]} />
  <RuleY data={stateage} {...groupY({x1: "min", x2: "max"}, {...xy, sort: {y: "x1"}})} />
  <Dot data={stateage} {...xy} fill="age" title="age" />
  <Text data={stateage} {...selectMinX({...xy, textAnchor: "end", dx: -6, text: "state"})} />
</Plot>

```js
xy = Plot.normalizeX("sum", {x: "population", y: "state", z: "state"})
```


To reduce code duplication, pull shared options out into an object (here `xy`) and then merge them into each mark‚Äôs options using the spread operator (`...`).
To improve accessibility, particularly for readers with color vision deficiency, the **symbol** channel can be used in addition to color (or instead of it) to represent ordinal data.

<Plot grid x={{label: "Body mass (g)"}} y={{label: "Flipper length (mm)"}} symbol={{legend: true}}>
  <Dot data={penguins} x="body_mass_g" y="flipper_length_mm" stroke="species" symbol="species" />
</Plot>

Plot uses the following default symbols for filled dots:

<Plot>
  <DotX data={["circle", "cross", "diamond", "square", "star", "triangle", "wye"]} fill="currentColor" symbol={identity} />
</Plot>

There is a separate set of default symbols for stroked dots:

<Plot>
  <DotX data={["circle", "plus", "times", "triangle2", "asterisk", "square2", "diamond2"]} stroke="currentColor" symbol={identity} />
</Plot>


The stroked symbols are based on [Heman Robinson‚Äôs research](https://www.tandfonline.com/doi/abs/10.1080/10618600.2019.1637746). There is also a *hexagon* symbol; it is primarily intended for the [hexbin transform](../transforms/hexbin.md). You can even specify a D3 or custom symbol type as an object that implements the [*symbol*.draw(*context*, *size*)](https://d3js.org/d3-shape/symbol#symbolType_draw) method.
The dot mark can be combined with the [stack transform](../transforms/stack.md). The diverging stacked dot plot below shows the age and gender distribution of the U.S. Congress in 2023.

<Plot aspectRatio={1} x={{label: "Age (years)"}} y={{
    grid: true,
    label: "‚Üê Women ¬∑ Men ‚Üí",
    labelAnchor: "center",
    tickFormat: Math.abs
  }}>
  <Dot data={congress} {...stackY2({
        x: (d) => 2023 - d.birthday.getUTCFullYear(),
        y: (d) => d.gender === "M" ? 1 : -1,
        fill: "gender",
        title: "full_name"
      })} />
  <RuleY data={[0]} />
</Plot>


The stackY2 transform places each dot at the upper bound of the associated stacked interval, rather than the middle of the interval as when using stackY. Hence, the first male dot is placed at *y* = 1, and the first female dot is placed at *y* = -1.

The [dodge transform](../transforms/dodge.md) can also be used to produce beeswarm plots; this is particularly effective when dots have varying radius.
Dots are sorted by descending radius by default <VersionBadge version="0.5.0" /> to mitigate occlusion; the smallest dots are drawn on top. Set the **sort** option to null to draw them in input order. Use the checkbox below to see the effect of sorting on a bubble map of U.S. county population.

<p>
  <label className="label-input">
    Use¬†default sort:
    <input type="checkbox" checked={sorted} onChange={(e) => setSorted(e.target.checked)} />
  </label>
</p>

<Plot projection="albers-usa">
  <Geo data={statemesh} strokeOpacity={0.4} />
  <Dot data={counties} {...geoCentroid({
      r: (d) => d.properties.population,
      fill: "currentColor",
      stroke: "var(--vp-c-bg)",
      strokeWidth: 1,
      sort: sorted ? undefined : null
    })} />
</Plot>

The dot mark can also be used to construct a [quantile-quantile (QQ) plot](https://observablehq.com/@observablehq/qq-plot) for comparing two univariate distributions.

## Dot options

In addition to the [standard mark options](../features/marks.md#mark-options), the following optional channels are supported:

* **x** - the horizontal position; bound to the *x* scale
* **y** - the vertical position; bound to the *y* scale
* **r** - the radius (area); bound to the *r* (radius) scale, which defaults to *sqrt*
* **rotate** - the rotation angle in degrees clockwise
* **symbol** - the categorical symbol; bound to the *symbol* scale <VersionBadge version="0.4.0" />

If either of the **x** or **y** channels are not specified, the corresponding position is controlled by the **frameAnchor** option.

The following dot-specific constant options are also supported:

* **r** - the effective radius (length); a number in pixels
* **rotate** - the rotation angle in degrees clockwise; defaults to 0
* **symbol** - the categorical symbol; defaults to *circle* <VersionBadge version="0.4.0" />
* **frameAnchor** - how to position the dot within the frame; defaults to *middle*

The **r** option can be specified as either a channel or constant. When the radius is specified as a number, it is interpreted as a constant; otherwise it is interpreted as a channel. The radius defaults to 4.5 pixels when using the **symbol** channel, and otherwise 3 pixels. Dots with a nonpositive radius are not drawn.

The **stroke** defaults to *none*. The **fill** defaults to *currentColor* if the stroke is *none*, and to *none* otherwise. The **strokeWidth** defaults to 1.5. The **rotate** and **symbol** options can be specified as either channels or constants. When rotate is specified as a number, it is interpreted as a constant; otherwise it is interpreted as a channel. When symbol is a valid symbol name or symbol object (implementing the draw method), it is interpreted as a constant; otherwise it is interpreted as a channel. If the **symbol** channel‚Äôs values are all symbols, symbol names, or nullish, the channel is unscaled (values are interpreted literally); otherwise, the channel is bound to the *symbol* scale.

## dot(*data*, *options*)
```js
Plot.dot(sales, {x: "units", y: "fruit"})
```

Returns a new dot with the given *data* and *options*. If neither the **x** nor **y** nor **frameAnchor** options are specified, *data* is assumed to be an array of pairs [[*x‚ÇÄ*, *y‚ÇÄ*], [*x‚ÇÅ*, *y‚ÇÅ*], [*x‚ÇÇ*, *y‚ÇÇ*], ‚Ä¶] such that **x** = [*x‚ÇÄ*, *x‚ÇÅ*, *x‚ÇÇ*, ‚Ä¶] and **y** = [*y‚ÇÄ*, *y‚ÇÅ*, *y‚ÇÇ*, ‚Ä¶].

## dotX(*data*, *options*)
```js
Plot.dotX(cars.map((d) => d["economy (mpg)"]))
```

Equivalent to [dot](#dot) except that if the **x** option is not specified, it defaults to the identity function and assumes that *data* = [*x‚ÇÄ*, *x‚ÇÅ*, *x‚ÇÇ*, ‚Ä¶].

If an **interval** is specified, such as d3.utcDay, **y** is transformed to (*interval*.floor(*y*) + *interval*.offset(*interval*.floor(*y*))) / 2. If the interval is specified as a number *n*, *y* will be the midpoint of two consecutive multiples of *n* that bracket *y*. Named UTC intervals such as *day* are also supported; see [scale options](../features/scales.md#scale-options).

## dotY(*data*, *options*)
```js
Plot.dotY(cars.map((d) => d["economy (mpg)"]))
```

Equivalent to [dot](#dot) except that if the **y** option is not specified, it defaults to the identity function and assumes that *data* = [*y‚ÇÄ*, *y‚ÇÅ*, *y‚ÇÇ*, ‚Ä¶].

If an **interval** is specified, such as d3.utcDay, **x** is transformed to (*interval*.floor(*x*) + *interval*.offset(*interval*.floor(*x*))) / 2. If the interval is specified as a number *n*, *x* will be the midpoint of two consecutive multiples of *n* that bracket *x*. Named UTC intervals such as *day* are also supported; see [scale options](../features/scales.md#scale-options).

## circle(*data*, *options*) <VersionBadge version="0.5.0" />
Equivalent to [dot](#dot) except that the **symbol** option is set to *circle*.

## hexagon(*data*, *options*) <VersionBadge version="0.5.0" />
Equivalent to [dot](#dot) except that the **symbol** option is set to *hexagon*.
